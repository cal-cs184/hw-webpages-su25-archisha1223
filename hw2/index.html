<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async 
			src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
				text-align: left;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Summer 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Name: Archisha Nangia </div>

		<br>

		Link to main webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-archisha1223/">https://cal-cs184.github.io/hw-webpages-su25-archisha1223/</a>
		
		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw2-meshedit-square">https://github.com/cal-cs184/hw2-meshedit-square</a>

		<br>

		Link to website repo: <a href="https://github.com/cal-cs184/hw-webpages-su25-archisha1223">https://github.com/cal-cs184/hw-webpages-su25-archisha1223</a>
		
		<figure>
			<img src="overview.png" alt="Teapot" style="width:70%"/>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this assignment, I implemented a mesh editing system for geomtetric modeling using the half-edge mesh data structure. The early tasks focused on evaluating Bezier curves and surfaces using de Casteljau's algorithm. I also worked on half-edge operations to flip and split
		edges. The later tasks involved implementing a full loop subdivision algorithm. Loop subdivision depends heavily on correct splitting and flipping behavior. Altogether, the assignment demonstrated how low-level geometric operations can be orchestrated to perform high-level 
		surface modeling. From this assignment, I gained a deeper understanding of mesh representation and processing. 
			
		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h2>Part 1: Bezier curves with 1D de Casteljau subdivision</h2>
		Bezier curves and surfaces are used to model smooth and infinitely scalable curves and surfaces. To evaluate Bezier curves, I implemented de Casteljau's algorithm using an iterative approach.  
		<p>
  		Given <em>n</em> control points \( p_1, \ldots, p_n \) and the parameter \( t \), I used linear interpolation to compute the \( n - 1 \) intermediate control points at the parameter \( t \) 
  		in the next subdivision level, \( p_1', \ldots, p_{n-1}' \), where
		</p>
		<p style="text-align: center;">
 		 \( p_i' = \text{lerp}(p_i, p_{i+1}, t) = (1 - t)p_i + tp_{i+1} \)
		</p>

		<p>
		The next step uses the points from the previous step, and decreases the number of points by one each time. I repeated this process until eventually, one point remained.
		This is the point on the Bezier curve corresponding to the current \( t \) value. The path traced by this final point as \( t \) varies, defines the curve.

		<p>Below is a custom 6 control point Bezier curve highlighting each step of the implemented algorithm.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1_step0.png" width="400px"/>
				</td>
			  </tr>
   			  <tr>
				<td style="text-align: center;">
				  <img src="1_step1.png" width="400px"/>
				</td>
			  </tr>
    			  <tr>
				<td style="text-align: center;">
				  <img src="1_step2.png" width="400px"/>
				</td>
			  </tr>
   			  <tr>

				<td style="text-align: center;">
				  <img src="1_step3.png" width="400px"/>
				</td>
			  </tr>
                          <tr>
				<td style="text-align: center;">
				  <img src="1_step4.png" width="400px"/>
				</td>
			  </tr>
   			  <tr>
				<td style="text-align: center;">
				  <img src="1_step5.png" width="400px"/>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="1_step6.png" width="400px"/>
				</td>
			  </tr>
			</table>
		<p>Below is a slightly different Bezier curve.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1_diffCurve.png" width="400px"/>
				</td>
			  </tr>
			</table>
		</div>

			
		<h2 style="text-align: left;">Part 2: Bezier surfaces with separable 1D de Casteljau</h2>
		<p> Here, I adapted my implementation from Bezier curves to Bezier surfaces. A Bezier surface is defined over a 2D grid of control points. The de Casteljau algorithm extends 
		to Bezier surfaces by performing linear interpolation in two stages: one along the rows in the <i>u</i> direction, and then along the resulting set of points across the <i>v</i> axis. 
		Given an <i>N × N</i> grid of 3D control points, I utilized <code>evaluate1D</code> twice. First, I evaluated each row using the <i>u</i> parameter and produced a list of intermediate points. 
		Then, I applied the same interpolation process along the <i>v</i> direction. The <code>evaluate1D</code> method repeatedly calls <code>evaluateStep</code> until a single point remains. 
		This final point represents the evaluated surface point at (<i>u</i>, <i>v</i>).
		</p>

		<p>Below is an image of teapot.bez rendered using this implementation.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="2_bez.png" width="400px"/>
			
				</td>
			  </tr>
			</table>
		</div>
		

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h2>Part 3: Area-weighted vertex normals</h2>
		In this task, I computed vertex normals by averaging the normals of adjacent faces, weighted by area. This method allows for better shading for smooth surfaces rather than 
		the default flat shading. I used the half-edge data structure to loop through all neighboring triangles of a given vertex. For each face, I retrieved its three vertex positions 
		using half-edge traversal (by using h->next()->vertex() and h->next()->next()->vertex()). I computed the face normal using a cross product. Since the magnitude of the cross 
		product corresponds to the triangle’s area, I summed these normals to find the area-weighted result. After the loop, I normalized the summed vector to get a unit vertex normal 
		for smooth shading.

		<p>Below is a comparison of teapot shading with and without vertex normals.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="3_before.png" width="500px"/>
	
				</td>
				<td style="text-align: center;">
				  <img src="3_after.png" width="500px"/>
		
				</td>
			  </tr>
			</table>
		</div>

		<h2>Part 4: Edge flip</h2>
		In this task, I implemented a local remeshing operation to flip an edge. The goal of edge flipping is to rotate the shared edge of two adjacent triangles to connect the opposite 
		pair of vertices, changing the local mesh connectivity but preserving the shape. 
		To implement the edge flip operation, I began by checking if the input edge is a boundary edge, which cannot be flipped. If it is not, I proceeded to list all local references 
		involved in the operation of two triangles which includes 10 half-edges, 4 verticies, 5 edges, and 2 faces. 

		<p>
		One key bug I encountered was black or disappearing faces after multiple edge flips, where I could successfully flip edges but upon flipping a consecutive edge, the face would disappear. 
		I found that this was caused by incorrect face pointers and incorrect next relationships. Edge flipping is especially sensitive to the order in which pointers are updated. If even 
		one pointer is wrong or missing, the shading will break. I fixed this bug by carefully drawing out the original and resulting triangle configurations and verifying each pointer assignment 
		against the diagram. Another helpful debugging trick was using the GUI to flip an edge, then immediately hovering over each triangle to check which face and vertex pointers were wrong. 
		This technique made it easier to narrow down incorrect relationships. By visually listing out the half-edges, verticies, edges, and faces, I was quickly able to follow the diagram and 
		correct my implementation. 
		</p>

		<p>Below is the diagram I created for the implementation.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="diagram_before.png" width="400px"/>
				  <figcaption>Before</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="diagram_flip.png" width="400px"/>
				  <figcaption>After</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p>Here, we see the before and after of applying edge flips.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="4_before.png" width="400px"/>
	
				</td>
				<td style="text-align: center;">
				  <img src="4_after.png" width="400px"/>

				</td>
			  </tr>
			</table>
		</div>

			
		<h2>Part 5: Edge split</h2>
		In this task, I implemented a local remeshing operation to flip an edge. The goal of splitting an edge is to split the two adjacent triangles into four smaller ones, connected by the new 
		vertex placed at the midpoint of the edge. 
		To implement the edge split operation, I created another diagram highlighting all the new pointers and utilizing the same "old" pointers from Part 4. The key difference here was adding a 
		new midpoint vertex <i>m<i>, 6 new half-edges, and 2 new faces. I utilized the same logic as Part 4, and similarly setNeighbors in the counterclockwise direction. 
		By spending time on creating an accurate diagram, I faced no challenges and did not have any difficult bugs in this task.


		<p>Below is the diagram I created for the implementation.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="diagram_before.png" width="400px"/>
				  <figcaption>Before</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="diagram_split.png" width="400px"/>
				  <figcaption>After</figcaption>
				</td>
			  </tr>
			</table>
		</div>
			
		<p>Below, we see the before and after of applying edge splits.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="5_before.png" width="400px"/>
					
				</td>
				<td style="text-align: center;">
				  <img src="5_after.png" width="400px"/>

				</td>
				<td style="text-align: center;">
				  <img src="5_afterFlips.png" width="400px"/>
					<figcaption>Split and Flip</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="5_afterFlips2.png" width="400px"/>
					<figcaption>Split and Flip</figcaption>

				</td>
			  </tr>
			</table>
		</div>

			
		<h2>Part 6: Loop subdivision for mesh upsampling</h2>
		In this task, I implemented a mesh upsampling method called loop subdivision. Loop subdivision upsamples a mesh by subdividing each of its triangles into four smaller triangles and then 
		updating the vertices of subdivided mesh based on a weighting scheme. The output of this algorithm is that the mesh becomes rounder and more concentrated towards its center. 
		To implement this, I used the 5 step process outlined in the spec:

		<ol>
		  <li>1. Compute new positions for all the vertices:
		    For each vertex, I traversed its neighbors using the half-edge structure and computed a weighted average of their positions. 
		    I applied the Loop subdivision weighting formula using the number of neighbors <code>n</code>, and 
		    assigned \( u = \frac{3}{16} \) when \( n = 3 \), and \( u = \frac{3}{8n} \) otherwise. I stored the new positions in 
		    <code>Vertex::newPosition</code> and marked all original vertices with <code>isNew = false</code>.
		  </li>
		
		  <li>2. Compute the updated vertex position for edges: </strong>
		    For each edge, I identified the two endpoints and the two opposite vertices. 
		    I then computed the new position using the weighted formula:<br>
		    \[
		    \frac{3}{8}(a + b) + \frac{1}{8}(c + d)
		    \]<br>
		    and stored it in <code>Edge::newPosition</code>. All existing edges were marked with <code>isNew = false</code>.
		  </li>
		
		  <li>3. Split every edge:
		    I recorded a list of all edges in the original mesh before performing any splits. Then, for each of these edges, I called <code>splitEdge</code>, 
		    assigned the stored <code>newPosition</code> to that midpoint vertex, and marked it as a newly created vertex where (<code>isNew = true</code>).
		  </li>
		
		  <li>4. Flip edges:
		    After splitting, I iterated through all edges again and flipped any <em>new edge</em> that connects a <em>new</em> and <em>old</em> vertex. 
		    This allows the mesh to preserve smoothness and ensure a uniform subdivision pattern.
		  </li>
		
		  <li>5. Update Final Positions:
		    I assigned the <code>newPosition</code> for each vertex in the mesh to update the finalized geometry.
		  </li>
		</ol>
		
		<p>
		One major bug I encountered was not initializing the <code>isNew</code> flags correctly in <code>splitEdge</code>. Specifically, I initially did not realize the
		necessity to mark the newly created edges and vertex inside <code>splitEdge</code> with <code>isNew = true</code>. This caused the flipping logic in Step 4 to 
		behave incorrectly where corners and edges spiked out more. Once I fixed this, the subdivision pattern became consistent and smoothened the edges correctly. 
		</p>


		<p>Below, I implemented loop subdivision on a torus, and we can notice that the edges disappear and the figure becomes more rounded and concentrated towards its center.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="5_int1.png" width="300px"/>
			
				</td>
				<td style="text-align: center;">
				  <img src="5_int2" width="300px"/>
				  
				</td>
				<td style="text-align: center;">
				  <img src="5_int3.png" width="300px"/>
			
				</td>
				<td style="text-align: center;">
				  <img src="5_int4" width="300px"/>
				  
				</td>
			  </tr>
			</table>
		</div>

	

		<p>Below, I implemented loop subdivision on the standard cube.dae, and we can notice that the cube becomes slightly asymmetric after repeated subdivisions. This is due to the face of the
		cube having a diagonal edge in only one direction. Hence, uneven edge configurations yield inconsistent averaging weights, resulting in asymmetric renderings.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="5_b1.png" width="300px"/>
			
				</td>
				<td style="text-align: center;">
				  <img src="5_b2" width="300px"/>
				  
				</td>
				<td style="text-align: center;">
				  <img src="5_b3.png" width="300px"/>
			
				</td>
				<td style="text-align: center;">
				  <img src="5_b4" width="300px"/>
				  
				</td>
				<td style="text-align: center;">
				  <img src="5_b5" width="300px"/>
				  
				</td>
			  </tr>
			</table>
		</div>

		<p>To fix this, we can pre-process the cube with edge flips and splits. These edits helped distribute connectivity more evenly across the mesh. 
		As a result, the cube subdivided into a more symmetric sphere-like shape. </p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="5_a1" width="300px"/>
	
				</td>
				<td style="text-align: center;">
				  <img src="5_a2.png" width="300px"/>
		
				</td>
				<td style="text-align: center;">
				  <img src="5_a3" width="300px"/>
	
				</td>
				<td style="text-align: center;">
				  <img src="5_a4.png" width="300px"/>
		
				</td>
				<td style="text-align: center;">
				  <img src="5_a5" width="300px"/>
	
				</td>
		
			  </tr>
			</table>
		</div>
		</div>
	</body>
</html>
